# cpp-ood-dna-sequence-abuzaid268

This design is an implementation of DNA sequence

DNA sequences are composed of four types of nucleotides; 

The nucleotides are marked A (Adenine), G (Guanine), C (Cytosine) and T (Thymine).

A full DNA molecule usually consists of two strands, connected to each other in base-pair connections: As with Ts, and Cs with Gs. 

Three successive nucleotides generate a codon, which might be chemically "read" in various ways.

A full DNA sequence might be very long - for example, the full human genome holds ~3*109 nucleotides. However, lots of work can be done with relatively short sequences that represent a specific region within the DNA.

The Sequence is encrypted in memory, instead of having each char with a byte of memory, four nucleotides occupy 1 byte of memory, encryption goes as {"A" : 00, "C" : 01 , "G" : 10, "T": 11}

## The following commands are being used to generate new sequences:

### Sequence Creation Commands
The following commands are being used to generate new sequences:
#### 1- new

> cmd >>> new <sequence> [@<sequence_name>]
  
If the @<sequence_name> is used, then this will be the name of the new sequence.

Otherwise, a default name will be provided - seq1 (or seq2, seq3 and so on, if the name is already taken).

The new sequence, its name and its number (internal ID, starting with 1) are printed.

For example:
> cmd >>> new ATACTGCCTGAATAC @short_seq
will create that sequence;
if this is the first sequence, it will be numbered "1" and the following will be printed:

[1] short_seq: ATACTGCCTGAATAC.


#### 2- load

> cmd >>> load <file_name>  [@<sequence_name>]
loads the sequence from the file, assigns it with a number (ID) and a default name, if one was not provided (based on the file name, possibly postfixed with a number if the name already exists), and prints it.
For example:
> cmd >>> load my_dna_seq.rawdna
will load the sequence from the file my_dna_seq.rawdna and will print its assigned ID, its name and the sequence (no more than 40 chars; If there are more in the sequence, it prints the first 32, then an ellipsis, and then the last three ones). So, a typical output might be:
[14] my_dna_seq: AACGTTTTTGAACACCAGTCAACAACTAGCCA...TTG

#### 3- dup
> cmd >>> dup <seq> [@<new_seq_name>]
duplicates the sequence.
If a new name is not provided, then it will be based on the name of <seq>, suffixed by _1 (or _2, _3, ... if the name is already taken).
For example:
> cmd >>> dup #22
will result in
[23] conseq_1_1: ATACTGCCTGAATACAGCATAGCATTGCCT

## Sequence Manipulation Commands
### The following commands manipulate existing sequences:
Their default behavior is to modify the source sequence in-place (that is, the original ID and name of the sequence are left the same, only its content is modified).

If a colon : appears after the command's argument, then the original sequence is left untouched, and a new sequence is generated with the manipulation results.
If an argument of the form @<new_seq_name> is provided after the colon, then this is the name of the new sequence.
Otherwise, if @@ instead, then the name of the new sequence is automatically generated by the app.

Each command might generate a different default name.
When a sequence is required as a source, both ID (#<seq_id>) or name (@seq_name) are acceptable, unless otherwise defined.
#### 4-slice
> cmd >>> slice <seq> <from_ind> <to_ind> [: [@<new_seq_name>|@@]]
Slices the sequence, so that starts in <from_ind> (0-based index) and ends in <to_ind> (inclusive).
If @<new_seq_name is provided, the results will create a new sequence with that name.
If @@ is provided, the results will create a new sequence with auto-generate name, based on the name of the original sequence, with the suffix _s1 (or, if that name is already occupied, with the suffix _s2, and so on). 
For example:
Assuming that the former short_seq's ID is 1, the following command:
> cmd >>> slice #1 4 9
will change the sequence to TGCCT (Letters at indices 4,5,6,7,8) and print the output:
[1] short_seq: TGCCT
If @@ was provided to the same command, then sequence 1 would have not changed, and a new sequence would have been generated instead.
A typical call, then, might look like:
> cmd >>> slice #1 4 8 : @@
[19] short_seq_s1: TGCCT

#### 5-replace
> cmd >>> replace <seq> <index> <new_letter> [: [@<new_seq_name>|@@]]
replaces the letter in the (0-based) index of <seq> by <new_letter>.
If @<new_seq_name> is provided, the original sequence is left untouched and the result is put in a newly created sequence with that name.
If @@ is provided, the name is based on the original sequence, with the suffix _r1 (or, if that name is already existing, _r2 and so on).
The command might get more than a single replacement. In that case, after <seq> there will be more than one pair of <index> and <new_letter>.
For example:
> cmd >>> replace @short_seq_s1 0 A 3 A : @repl_seq
will result in the following output:
[20] repl_seq: AGCAT
  
#### 6-concat
> cmd >>> concat <seq_1> <seq_2> [: [@<new_seq_name>|@@]]
concatenates <seq_2> at the end of seq_1.
If the colon : syntax is used, then both seq_1 and seq_2 are left untouched, and the result is being put in a new sequence, named either as provided by <new_seq_name>.
If the @@ syntax is used, automatically generated to include the name of <seq_1>, an underscore, then the name of seq_2 and finally the suffix _c1 (or _c2, _c3, ..., if the name is already taken).

For example:
The result of:
> cmd >>> concat #19 @repl_seq : @@
will result in a new sequence and will print:
[21] short_seq_s1_repl_seq_c1: TGCCTAGCAT
Concatenation is also possible for more than two sequences.
In this case, the default name for the new sequence, in case that: @@ is provided, will be conseq_1 (or conseq_2 and so on, if that name is already taken).
For example:
The following command:
> cmd >>> concat #1 #20 #20 #19 : @@
will result the following:
[22] conseq_1: ATACTGCCTGAATACAGCATAGCATTGCCT
If no "colon argument" is used, then the command modifies only the first sequence (e.g., in the last example - #1) and the other sequences are left untouched.

#### 7-pair
> cmd >>> pair <seq> [: [@<new_seq_name>|@@]]
Create sequence <seq> with its pair sequence, that is, each T is replaced by an A (and vice versa), and each C is replaced by a G (and vice versa).
If an auto-generate name is required (@@ is used), then it will be the original name, suffixed with _p1 (or _p2, _p3, ... if the name is already taken).
For example:> cmd >>> pair #21 : @@
will produce:
[24] short_seq_s1_repl_seq_c1_p1: ACGGATCGTA
  
## Sequence Management Commands

### This is a list of commands that manage existing sequences (without manipulating them).
#### 8-rename
> cmd >>> rename <seq> @<new_name>
renames the name of the sequence to the new name.
If that name is already taken, an explanatory error message is printed.
  
#### 9-del
> cmd >>> del <seq>
deletes that sequence.
Before deleting it, the user is asked to confirm that:
Confirmation is done by entering y or Y, Entering n or N cancels the deletion. Any other input will result in a message that asks the user again to confirm the deletion.
Once confirmed, the sequence is deleted and a message is printed. Otherwise, a cancellation message is printed.
So, a deletion scenario might look like:
> cmd >>> del #23
Do you really want to delete conseq_1_1: ATACTGCCTGAATACAGCATAGCATTGCCT?
Please confirm by 'y' or 'Y', or cancel by 'n' or 'N'.
> confirm >>> x
You have typed an invalid response. Please either confirm by 'y'/'Y', or cancel by 'n'/'N'.
> confirm >>> Y
Deleted: [23] conseq_1_1: ATACTGCCTGAATACAGCATAGCATTGCCT

#### 10-reenum
> cmd >>> reenum
re-enumerates all the sequences, so that their numbers are 1..n, where n is the number of sequences. The original order is kept.

#### 11-save
> cmd >>> save <seq> [<filename>]
saves sequence <seq> to a file.
If <filename> is not provided, the sequence name is being used.
The filename is suffixed by .rawdna.
  
## Sequence Analysis Commands
#### 12-len
> cmd >>> len <seq_id>
prints the length of the sequence.
For example:
If sequence #34 is AAATGTGATG, then it will look like this:
> cmd >>> len #34
10

#### 13-find
The find command finds a sub-sequence within a sequence.
It has two flavors:
1. Takes an expressed sub-sequence:
> cmd >>> find <seq> <expressed_sub_seq>
returns the (0-based) index of the first appearance of <expressed_sub_seq> in the sequence <seq>.
Thus, for example:
If sequence #11 is AACCTTGGAATTCCGGAA and we are looking for the sub-sequence GG, it will look like:
> cmd >>> find #11 GG
7
2. Refers an existing sub-sequence:
> cmd >>> find <seq_to_find_in> <seq_to_be_found>
Thus, for example:
If seq #11 is as appears above, and sequence #25 is CTTGGA, it might look like:
> cmd >>> find #11 #25
4

#### 14-count
count works in a similar way to find, only it returns the number of instances of the sub-sequence within the larger sequence.
Like find, it has two flavors, one that takes an expressed sub-sequence, and one that refers an existing sub-sequence:
> cmd >>> count <seq> <expressed_sub_seq>
> cmd >>> count <seq_to_find_in> <seq_to_be_found>

#### 15-findall
> cmd >>> findall <seq> <expressed_sub_seq>
> cmd >>> findall <seq_to_find_in> <seq_to_be_found>
work very similar to find, only they return all the indices where the sub-sequence appears.
Thus, for example:
Using the above sequence for sequence #11, it might look like:
> cmd >>> findall #11 GA
8 16
> cmd >>> findall #11 AA
1 9 17
  
